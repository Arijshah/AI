"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[277],{8453(e,n,i){i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}},9581(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"physical-ai/the-digital-twin-gazebo-unity/physics-and-collision-modeling","title":"Physics and Collision Modeling","description":"Overview","source":"@site/docs/physical-ai/the-digital-twin-gazebo-unity/physics-and-collision-modeling.md","sourceDirName":"physical-ai/the-digital-twin-gazebo-unity","slug":"/physical-ai/the-digital-twin-gazebo-unity/physics-and-collision-modeling","permalink":"/AI/docs/physical-ai/the-digital-twin-gazebo-unity/physics-and-collision-modeling","draft":false,"unlisted":false,"editUrl":"https://github.com/arijh/physical-ai-book/tree/main/packages/create-docusaurus/templates/shared/docs/physical-ai/the-digital-twin-gazebo-unity/physics-and-collision-modeling.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"Physics and Collision Modeling","title":"Physics and Collision Modeling"},"sidebar":"docs","previous":{"title":"Introduction to Gazebo Simulation","permalink":"/AI/docs/physical-ai/the-digital-twin-gazebo-unity/introduction-to-gazebo-simulation"},"next":{"title":"Unity-Based Visualization","permalink":"/AI/docs/physical-ai/the-digital-twin-gazebo-unity/unity-based-visualization"}}');var s=i(4848),o=i(8453);const r={sidebar_label:"Physics and Collision Modeling",title:"Physics and Collision Modeling"},a="Physics and Collision Modeling",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Hands-on Steps",id:"hands-on-steps",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Small Simulation",id:"small-simulation",level:2},{value:"Quick Recap",id:"quick-recap",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"physics-and-collision-modeling",children:"Physics and Collision Modeling"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Physics simulation is the cornerstone of creating realistic digital twins for robotic systems. In Gazebo, accurate physics modeling ensures that robots behave similarly in simulation and reality. This lesson explores the fundamental concepts of physics simulation, including mass properties, friction, collision detection, and realistic material interactions. Understanding these concepts is crucial for creating simulations that faithfully represent real-world robot behaviors."}),"\n",(0,s.jsx)(n.p,{children:"Proper physics modeling allows for accurate testing of robot dynamics, interaction with objects, and validation of control algorithms before deployment on physical hardware."}),"\n",(0,s.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,s.jsx)(n.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Configure mass properties and inertial tensors for robot links"}),"\n",(0,s.jsx)(n.li,{children:"Set up realistic friction and contact properties"}),"\n",(0,s.jsx)(n.li,{children:"Model collision geometries and materials accurately"}),"\n",(0,s.jsx)(n.li,{children:"Implement custom physics properties for special objects"}),"\n",(0,s.jsx)(n.li,{children:"Validate physics models against real-world behavior"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"hands-on-steps",children:"Hands-on Steps"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mass Properties Setup"}),": Define mass and inertial properties for robot components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Friction Modeling"}),": Configure friction coefficients for different surfaces"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collision Detection"}),": Set up collision properties and contact models"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Material Properties"}),": Define realistic material behaviors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics Validation"}),": Compare simulation vs. real-world behavior"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Understanding of URDF and SDF formats (from Chapter 2)"}),"\n",(0,s.jsx)(n.li,{children:"Basic knowledge of physics concepts (mass, friction, collision)"}),"\n",(0,s.jsx)(n.li,{children:"Experience with Gazebo simulation setup"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,s.jsx)(n.p,{children:"Let's start by creating a detailed robot model with proper physics properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- physics_robot.urdf --\x3e\n<?xml version="1.0"?>\n<robot name="physics_robot">\n  \x3c!-- Materials --\x3e\n  <material name="blue">\n    <color rgba="0.0 0.0 0.8 1.0"/>\n  </material>\n  <material name="green">\n    <color rgba="0.0 0.8 0.0 1.0"/>\n  </material>\n  <material name="red">\n    <color rgba="0.8 0.0 0.0 1.0"/>\n  </material>\n  <material name="white">\n    <color rgba="1.0 1.0 1.0 1.0"/>\n  </material>\n\n  \x3c!-- Base Link with realistic physics properties --\x3e\n  <link name="base_link">\n    <visual>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.4 0.3 0.2"/>\n      </geometry>\n      <material name="white"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.4 0.3 0.2"/>\n      </geometry>\n    </collision>\n    <inertial>\n      \x3c!-- Realistic mass for a robot base (~10kg) --\x3e\n      <mass value="10.0"/>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      \x3c!-- Calculated inertia for a box: Ixx=1/12*m*(h\xb2+w\xb2), etc. --\x3e\n      <inertia ixx="0.108333" ixy="0.0" ixz="0.0"\n               iyy="0.133333" iyz="0.0"\n               izz="0.241667"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left Wheel with realistic friction --\x3e\n  <link name="left_wheel">\n    <visual>\n      <origin xyz="0 0 0" rpy="1.5708 0 0"/>\n      <geometry>\n        <cylinder length="0.05" radius="0.1"/>\n      </geometry>\n      <material name="blue"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0" rpy="1.5708 0 0"/>\n      <geometry>\n        <cylinder length="0.05" radius="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.8"/>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      \x3c!-- Inertia for a cylinder about its center axis --\x3e\n      <inertia ixx="0.0006" ixy="0.0" ixz="0.0"\n               iyy="0.0006" iyz="0.0"\n               izz="0.0025"/>\n    </inertial>\n  </link>\n\n  <joint name="left_wheel_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="left_wheel"/>\n    <origin xyz="0 0.175 0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n  </joint>\n\n  \x3c!-- Right Wheel --\x3e\n  <link name="right_wheel">\n    <visual>\n      <origin xyz="0 0 0" rpy="1.5708 0 0"/>\n      <geometry>\n        <cylinder length="0.05" radius="0.1"/>\n      </geometry>\n      <material name="blue"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0" rpy="1.5708 0 0"/>\n      <geometry>\n        <cylinder length="0.05" radius="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.8"/>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <inertia ixx="0.0006" ixy="0.0" ixz="0.0"\n               iyy="0.0006" iyz="0.0"\n               izz="0.0025"/>\n    </inertial>\n  </link>\n\n  <joint name="right_wheel_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="right_wheel"/>\n    <origin xyz="0 -0.175 0.05" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n  </joint>\n\n  \x3c!-- Manipulator Arm Base --\x3e\n  <link name="arm_base">\n    <visual>\n      <geometry>\n        <cylinder length="0.1" radius="0.05"/>\n      </geometry>\n      <material name="red"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.1" radius="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.00052" ixy="0.0" ixz="0.0"\n               iyy="0.00052" iyz="0.0"\n               izz="0.00025"/>\n    </inertial>\n  </link>\n\n  <joint name="arm_base_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="arm_base"/>\n    <origin xyz="0.15 0 0.1" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="10.0" velocity="2.0"/>\n  </joint>\n\n  \x3c!-- Upper Arm --\x3e\n  <link name="upper_arm">\n    <visual>\n      <origin xyz="0 0 0.15" rpy="1.5708 0 0"/>\n      <geometry>\n        <cylinder length="0.3" radius="0.03"/>\n      </geometry>\n      <material name="green"/>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.15" rpy="1.5708 0 0"/>\n      <geometry>\n        <cylinder length="0.3" radius="0.03"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.8"/>\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\n      <inertia ixx="0.00608" ixy="0.0" ixz="0.0"\n               iyy="0.00608" iyz="0.0"\n               izz="0.00036"/>\n    </inertial>\n  </link>\n\n  <joint name="shoulder_joint" type="revolute">\n    <parent link="arm_base"/>\n    <child link="upper_arm"/>\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="15.0" velocity="1.5"/>\n  </joint>\n\n  \x3c!-- Gazebo-specific physics properties --\x3e\n  <gazebo reference="base_link">\n    <material>Gazebo/White</material>\n    \x3c!-- Buoyancy if needed --\x3e\n    <gravity>1</gravity>\n    <mu1>0.3</mu1>  \x3c!-- Friction coefficient --\x3e\n    <mu2>0.3</mu2>  \x3c!-- Secondary friction coefficient --\x3e\n    <kp>1000000.0</kp>  \x3c!-- Contact stiffness --\x3e\n    <kd>100.0</kd>     \x3c!-- Contact damping --\x3e\n    <max_vel>10.0</max_vel>\n    <min_depth>0.001</min_depth>\n  </gazebo>\n\n  <gazebo reference="left_wheel">\n    <material>Gazebo/Blue</material>\n    \x3c!-- Higher friction for wheels to grip the ground --\x3e\n    <mu1>1.0</mu1>\n    <mu2>1.0</mu2>\n    <kp>1000000.0</kp>\n    <kd>100.0</kd>\n    \x3c!-- Wheel-specific properties --\x3e\n    <fdir1>1 0 0</fdir1>  \x3c!-- Direction of wheel friction --\x3e\n  </gazebo>\n\n  <gazebo reference="right_wheel">\n    <material>Gazebo/Blue</material>\n    <mu1>1.0</mu1>\n    <mu2>1.0</mu2>\n    <kp>1000000.0</kp>\n    <kd>100.0</kd>\n    <fdir1>1 0 0</fdir1>\n  </gazebo>\n\n  <gazebo reference="arm_base">\n    <material>Gazebo/Red</material>\n    <mu1>0.8</mu1>\n    <mu2>0.8</mu2>\n    <kp>1000000.0</kp>\n    <kd>100.0</kd>\n  </gazebo>\n\n  <gazebo reference="upper_arm">\n    <material>Gazebo/Green</material>\n    <mu1>0.6</mu1>\n    <mu2>0.6</mu2>\n    <kp>1000000.0</kp>\n    <kd>100.0</kd>\n  </gazebo>\n\n  \x3c!-- Differential drive plugin --\x3e\n  <gazebo>\n    <plugin name="differential_drive" filename="libgazebo_ros_diff_drive.so">\n      <ros>\n        <namespace>/physics_robot</namespace>\n        <remapping>cmd_vel:=cmd_vel</remapping>\n        <remapping>odom:=odom</remapping>\n      </ros>\n      <left_joint>left_wheel_joint</left_joint>\n      <right_joint>right_wheel_joint</right_joint>\n      <wheel_separation>0.35</wheel_separation>\n      <wheel_diameter>0.2</wheel_diameter>\n      <max_wheel_torque>20</max_wheel_torque>\n      <max_wheel_acceleration>1.0</max_wheel_acceleration>\n      <publish_odom>true</publish_odom>\n      <publish_odom_tf>true</publish_odom_tf>\n      <publish_wheel_tf>true</publish_wheel_tf>\n      <odometry_frame>odom</odometry_frame>\n      <robot_base_frame>base_link</robot_base_frame>\n    </plugin>\n  </gazebo>\n\n  \x3c!-- Joint state publisher --\x3e\n  <gazebo>\n    <plugin name="joint_state_publisher" filename="libgazebo_ros_joint_state_publisher.so">\n      <ros>\n        <namespace>/physics_robot</namespace>\n        <remapping>joint_states:=joint_states</remapping>\n      </ros>\n      <update_rate>30</update_rate>\n      <joint_name>left_wheel_joint</joint_name>\n      <joint_name>right_wheel_joint</joint_name>\n      <joint_name>arm_base_joint</joint_name>\n      <joint_name>shoulder_joint</joint_name>\n    </plugin>\n  </gazebo>\n</robot>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now let's create a complex world with different physics properties for various surfaces:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- physics_world.world --\x3e\n<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="physics_world">\n    \x3c!-- Include the default sun --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Add ground plane with specific physics properties --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Modify ground plane physics properties --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.8</mu>  \x3c!-- High friction for good grip --\x3e\n                <mu2>0.8</mu2>\n                <fdir1>0 0 1</fdir1>\n                <slip1>0.0</slip1>\n                <slip2>0.0</slip2>\n              </ode>\n            </friction>\n            <bounce>\n              <restitution_coefficient>0.1</restitution_coefficient>  \x3c!-- Low bounce --\x3e\n              <threshold>100000</threshold>\n            </bounce>\n            <contact>\n              <ode>\n                <soft_cfm>0</soft_cfm>\n                <soft_erp>0.2</soft_erp>\n                <kp>1e+13</kp>\n                <kd>1</kd>\n                <max_vel>100.0</max_vel>\n                <min_depth>0.001</min_depth>\n              </ode>\n            </contact>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <material>\n            <ambient>0.7 0.7 0.7 1</ambient>\n            <diffuse>0.7 0.7 0.7 1</diffuse>\n            <specular>0.01 0.01 0.01 1</specular>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Add a low-friction surface (ice) --\x3e\n    <model name="ice_surface">\n      <pose>3 0 0.01 0 0 0</pose>\n      <link name="ice_link">\n        <collision name="ice_collision">\n          <geometry>\n            <box>\n              <size>2 2 0.02</size>\n            </box>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.1</mu>  \x3c!-- Very low friction --\x3e\n                <mu2>0.1</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="ice_visual">\n          <geometry>\n            <box>\n              <size>2 2 0.02</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.9 0.9 1.0 0.8</ambient>\n            <diffuse>0.9 0.9 1.0 0.8</diffuse>\n            <specular>0.5 0.5 0.8 0.8</specular>\n          </material>\n        </visual>\n        <static>true</static>\n      </link>\n    </model>\n\n    \x3c!-- Add a high-friction surface (rubber mat) --\x3e\n    <model name="rubber_mat">\n      <pose>-3 0 0.01 0 0 0</pose>\n      <link name="rubber_link">\n        <collision name="rubber_collision">\n          <geometry>\n            <box>\n              <size>2 2 0.02</size>\n            </box>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>1.5</mu>  \x3c!-- High friction --\x3e\n                <mu2>1.5</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="rubber_visual">\n          <geometry>\n            <box>\n              <size>2 2 0.02</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.2 0.2 0.2 1</ambient>\n            <diffuse>0.2 0.2 0.2 1</diffuse>\n            <specular>0.1 0.1 0.1 1</specular>\n          </material>\n        </visual>\n        <static>true</static>\n      </link>\n    </model>\n\n    \x3c!-- Add various objects with different physics properties --\x3e\n\n    \x3c!-- Light box (easy to push) --\x3e\n    <model name="light_box">\n      <pose>1 1 0.2 0 0 0</pose>\n      <link name="box_link">\n        <collision name="box_collision">\n          <geometry>\n            <box>\n              <size>0.2 0.2 0.2</size>\n            </box>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.5</mu>\n                <mu2>0.5</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="box_visual">\n          <geometry>\n            <box>\n              <size>0.2 0.2 0.2</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.8 0.2 1</ambient>\n            <diffuse>0.8 0.8 0.2 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>0.5</mass>  \x3c!-- Light mass --\x3e\n          <inertia>\n            <ixx>0.003333</ixx>\n            <ixy>0.0</ixy>\n            <ixz>0.0</ixz>\n            <iyy>0.003333</iyy>\n            <iyz>0.0</iyz>\n            <izz>0.003333</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n    \x3c!-- Heavy cylinder (hard to move) --\x3e\n    <model name="heavy_cylinder">\n      <pose>-1 1 0.3 0 0 0</pose>\n      <link name="cylinder_link">\n        <collision name="cylinder_collision">\n          <geometry>\n            <cylinder>\n              <radius>0.15</radius>\n              <length>0.3</length>\n            </cylinder>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.8</mu>\n                <mu2>0.8</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="cylinder_visual">\n          <geometry>\n            <cylinder>\n              <radius>0.15</radius>\n              <length>0.3</length>\n            </cylinder>\n          </geometry>\n          <material>\n            <ambient>0.8 0.2 0.2 1</ambient>\n            <diffuse>0.8 0.2 0.2 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>5.0</mass>  \x3c!-- Heavy mass --\x3e\n          <inertia>\n            <ixx>0.140625</ixx>\n            <ixy>0.0</ixy>\n            <ixz>0.0</ixz>\n            <iyy>0.140625</iyy>\n            <iyz>0.0</iyz>\n            <izz>0.1125</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n    \x3c!-- Bouncy ball --\x3e\n    <model name="bouncy_ball">\n      <pose>0 -1 1 0 0 0</pose>\n      <link name="ball_link">\n        <collision name="ball_collision">\n          <geometry>\n            <sphere>\n              <radius>0.1</radius>\n            </sphere>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.3</mu>\n                <mu2>0.3</mu2>\n              </ode>\n            </friction>\n            <bounce>\n              <restitution_coefficient>0.8</restitution_coefficient>  \x3c!-- High bounce --\x3e\n              <threshold>100000</threshold>\n            </bounce>\n          </surface>\n        </collision>\n        <visual name="ball_visual">\n          <geometry>\n            <sphere>\n              <radius>0.1</radius>\n            </sphere>\n          </geometry>\n          <material>\n            <ambient>0.2 0.8 0.2 1</ambient>\n            <diffuse>0.2 0.8 0.2 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>0.3</mass>\n          <inertia>\n            <ixx>0.0006</ixx>\n            <ixy>0.0</ixy>\n            <ixz>0.0</ixz>\n            <iyy>0.0006</iyy>\n            <iyz>0.0</iyz>\n            <izz>0.0006</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n    \x3c!-- Physics engine parameters --\x3e\n    <physics name="default_physics" default="true" type="ode">\n      <max_step_size>0.001</max_step_size>  \x3c!-- Small step size for accuracy --\x3e\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>10</iters>\n          <sor>1.3</sor>\n        </solver>\n        <constraints>\n          <cfm>0.0</cfm>\n          <erp>0.2</erp>\n          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n          <contact_surface_layer>0.001</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now let's create a ROS 2 node to test physics interactions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# physics_interactor.py\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, Wrench, Point\nfrom std_msgs.msg import String\nfrom sensor_msgs.msg import JointState\nfrom gazebo_msgs.msg import ContactsState\nfrom gazebo_msgs.srv import ApplyBodyWrench, GetModelState\nimport math\nimport time\n\nclass PhysicsInteractor(Node):\n    """\n    Node to interact with physics simulation and test collision detection\n    """\n    def __init__(self):\n        super().__init__(\'physics_interactor\')\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/physics_robot/cmd_vel\', 10)\n        self.status_pub = self.create_publisher(String, \'/physics_status\', 10)\n\n        # Subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState, \'/physics_robot/joint_states\', self.joint_state_callback, 10)\n\n        self.contact_sub = self.create_subscription(\n            ContactsState, \'/gazebo/contact\', self.contact_callback, 10)\n\n        # Services\n        self.apply_wrench_cli = self.create_client(ApplyBodyWrench, \'/gazebo/apply_body_wrench\')\n        self.get_model_state_cli = self.create_client(GetModelState, \'/gazebo/get_model_state\')\n\n        # Timers\n        self.interaction_timer = self.create_timer(0.1, self.interaction_loop)\n\n        # Robot state\n        self.joint_positions = {}\n        self.joint_velocities = {}\n        self.contact_states = []\n        self.robot_position = Point()\n        self.robot_orientation = Point()\n\n        # Test parameters\n        self.test_phase = 0\n        self.test_start_time = self.get_clock().now()\n        self.test_sequence = [\n            self.test_basic_movement,\n            self.test_surface_interaction,\n            self.test_object_manipulation,\n            self.test_collision_response\n        ]\n\n        self.get_logger().info("Physics Interactor initialized")\n\n    def joint_state_callback(self, msg):\n        """Process joint state data"""\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.joint_positions[name] = msg.position[i]\n            if i < len(msg.velocity):\n                self.joint_velocities[name] = msg.velocity[i]\n\n    def contact_callback(self, msg):\n        """Process contact sensor data"""\n        self.contact_states = msg.states\n\n    def apply_force_to_body(self, body_name, force_x, force_y, force_z, duration=1.0):\n        """Apply a force to a specific body in the simulation"""\n        if not self.apply_wrench_cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().error(\'Service /gazebo/apply_body_wrench not available\')\n            return False\n\n        req = ApplyBodyWrench.Request()\n        req.body_name = body_name\n        req.wrench.force.x = force_x\n        req.wrench.force.y = force_y\n        req.wrench.force.z = force_z\n        req.duration.sec = int(duration)\n        req.duration.nanosec = int((duration - int(duration)) * 1e9)\n\n        future = self.apply_wrench_cli.call_async(req)\n        return future\n\n    def get_robot_state(self):\n        """Get the current state of the robot model"""\n        if not self.get_model_state_cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().error(\'Service /gazebo/get_model_state not available\')\n            return None\n\n        req = GetModelState.Request()\n        req.model_name = \'physics_robot\'\n        req.relative_entity_name = \'world\'\n\n        future = self.get_model_state_cli.call_async(req)\n        return future\n\n    def test_basic_movement(self):\n        """Test basic robot movement on normal surface"""\n        cmd = Twist()\n        cmd.linear.x = 0.3  # Move forward\n        cmd.angular.z = 0.0\n        self.cmd_vel_pub.publish(cmd)\n\n        self.get_logger().info("Test 1: Moving robot forward on normal surface")\n        return True\n\n    def test_surface_interaction(self):\n        """Test robot movement on different friction surfaces"""\n        cmd = Twist()\n        cmd.linear.x = 0.3\n        cmd.angular.z = 0.0\n        self.cmd_vel_pub.publish(cmd)\n\n        self.get_logger().info("Test 2: Moving robot across different surfaces (normal, ice, rubber)")\n        return True\n\n    def test_object_manipulation(self):\n        """Test interaction with objects of different masses"""\n        cmd = Twist()\n        cmd.linear.x = 0.2\n        cmd.angular.z = 0.0\n        self.cmd_vel_pub.publish(cmd)\n\n        # Apply a small force to the light box to see if it moves\n        self.apply_force_to_body(\'light_box::box_link\', 5.0, 0.0, 0.0, 0.5)\n\n        self.get_logger().info("Test 3: Interacting with light and heavy objects")\n        return True\n\n    def test_collision_response(self):\n        """Test collision detection and response"""\n        cmd = Twist()\n        cmd.linear.x = 0.1  # Slow movement to observe collisions\n        cmd.angular.z = 0.2  # Gentle rotation\n        self.cmd_vel_pub.publish(cmd)\n\n        self.get_logger().info("Test 4: Observing collision responses")\n        return True\n\n    def interaction_loop(self):\n        """Main interaction loop that runs different physics tests"""\n        current_time = self.get_clock().now()\n        elapsed = (current_time - self.test_start_time).nanoseconds / 1e9\n\n        # Run tests in sequence\n        if elapsed > 5.0 and self.test_phase < len(self.test_sequence):\n            self.test_sequence[self.test_phase]()\n            self.test_phase += 1\n            self.test_start_time = current_time\n\n        # Reset test sequence after all tests are done\n        if self.test_phase >= len(self.test_sequence):\n            self.test_phase = 0\n            self.test_start_time = current_time\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = f"Test Phase: {self.test_phase}, Elapsed: {elapsed:.1f}s, " \\\n                         f"Contacts: {len(self.contact_states)}, Joints: {len(self.joint_positions)}"\n        self.status_pub.publish(status_msg)\n\n        # Log contact information\n        if self.contact_states:\n            for contact in self.contact_states:\n                if len(contact.collision1_name) > 0 and len(contact.collision2_name) > 0:\n                    self.get_logger().info(f"Contact: {contact.collision1_name} vs {contact.collision2_name}")\n\ndef main(args=None):\n    rclpy.init(args=args)\n    interactor = PhysicsInteractor()\n\n    try:\n        rclpy.spin(interactor)\n    except KeyboardInterrupt:\n        interactor.get_logger().info("Physics Interactor stopped by user")\n    finally:\n        interactor.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"small-simulation",children:"Small Simulation"}),"\n",(0,s.jsx)(n.p,{children:"Let's create a physics validation tool that compares simulation behavior with expected real-world physics:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# physics_validator.py\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, Vector3\nfrom nav_msgs.msg import Odometry\nfrom sensor_msgs.msg import JointState, Imu\nfrom std_msgs.msg import Float32, String\nimport numpy as np\nimport math\nimport time\n\nclass PhysicsValidator(Node):\n    \"\"\"\n    Validates physics simulation against expected real-world behavior\n    \"\"\"\n    def __init__(self):\n        super().__init__('physics_validator')\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, '/physics_robot/cmd_vel', 10)\n        self.validation_pub = self.create_publisher(String, '/physics_validation', 10)\n\n        # Subscribers\n        self.odom_sub = self.create_subscription(Odometry, '/physics_robot/odom', self.odom_callback, 10)\n        self.joint_sub = self.create_subscription(JointState, '/physics_robot/joint_states', self.joint_callback, 10)\n        self.imu_sub = self.create_subscription(Imu, '/physics_robot/imu', self.imu_callback, 10)\n\n        # Timers\n        self.validation_timer = self.create_timer(0.1, self.validation_loop)\n\n        # Robot state tracking\n        self.position_history = []\n        self.velocity_history = []\n        self.acceleration_history = []\n        self.joint_positions = {}\n        self.joint_velocities = {}\n        self.linear_velocity = Vector3()\n        self.angular_velocity = Vector3()\n        self.orientation = Vector3()\n\n        # Validation parameters\n        self.start_time = self.get_clock().now()\n        self.last_position = None\n        self.last_velocity = None\n        self.validation_results = {\n            'friction_coefficient': None,\n            'momentum_conservation': None,\n            'energy_loss': None,\n            'collision_response': None\n        }\n\n        # Test parameters\n        self.test_stage = 0\n        self.test_start_time = self.get_clock().now()\n        self.test_commands = [\n            {'linear': 0.3, 'angular': 0.0, 'duration': 3.0},  # Move straight\n            {'linear': 0.0, 'angular': 0.5, 'duration': 2.0},  # Rotate\n            {'linear': 0.2, 'angular': 0.0, 'duration': 3.0},  # Move again\n            {'linear': 0.0, 'angular': 0.0, 'duration': 2.0}   # Stop\n        ]\n        self.current_command = 0\n\n        self.get_logger().info(\"Physics Validator initialized\")\n\n    def odom_callback(self, msg):\n        \"\"\"Process odometry data for validation\"\"\"\n        current_pos = msg.pose.pose.position\n        current_vel = msg.twist.twist.linear\n\n        # Store position and velocity for analysis\n        self.position_history.append((current_pos.x, current_pos.y, current_pos.z))\n        self.velocity_history.append((current_vel.x, current_vel.y, current_vel.z))\n\n        # Calculate acceleration if we have previous velocity\n        if self.last_velocity is not None:\n            dt = 0.1  # Assuming 10Hz update rate\n            ax = (current_vel.x - self.last_velocity.x) / dt\n            ay = (current_vel.y - self.last_velocity.y) / dt\n            az = (current_vel.z - self.last_velocity.z) / dt\n            self.acceleration_history.append((ax, ay, az))\n\n        self.last_velocity = current_vel\n\n    def joint_callback(self, msg):\n        \"\"\"Process joint state data\"\"\"\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.joint_positions[name] = msg.position[i]\n            if i < len(msg.velocity):\n                self.joint_velocities[name] = msg.velocity[i]\n\n    def imu_callback(self, msg):\n        \"\"\"Process IMU data for validation\"\"\"\n        self.linear_velocity = msg.linear_acceleration\n        self.angular_velocity = msg.angular_velocity\n        self.orientation = msg.orientation\n\n    def calculate_physics_metrics(self):\n        \"\"\"Calculate various physics validation metrics\"\"\"\n        if len(self.position_history) < 10:\n            return  # Need enough data points\n\n        # Calculate average velocity over recent history\n        recent_positions = self.position_history[-10:]\n        dx = recent_positions[-1][0] - recent_positions[0][0]\n        dy = recent_positions[-1][1] - recent_positions[0][1]\n        dt = len(recent_positions) * 0.1  # 10 samples at 10Hz\n        avg_velocity = math.sqrt(dx*dx + dy*dy) / dt if dt > 0 else 0\n\n        # Calculate velocity from wheel joints (for comparison)\n        if 'left_wheel_joint' in self.joint_velocities and 'right_wheel_joint' in self.joint_velocities:\n            left_vel = self.joint_velocities['left_wheel_joint']\n            right_vel = self.joint_velocities['right_wheel_joint']\n            wheel_radius = 0.1  # From URDF\n            expected_vel = (left_vel + right_vel) * wheel_radius / 2.0\n\n        # Calculate energy loss (should be minimal in ideal conditions)\n        if len(self.velocity_history) >= 2:\n            current_speed = math.sqrt(\n                self.velocity_history[-1][0]**2 +\n                self.velocity_history[-1][1]**2\n            )\n            initial_speed = math.sqrt(\n                self.velocity_history[0][0]**2 +\n                self.velocity_history[0][1]**2\n            )\n            energy_loss = abs(initial_speed - current_speed) / initial_speed if initial_speed > 0 else 0\n\n        return {\n            'avg_velocity': avg_velocity,\n            'expected_velocity': expected_vel if 'expected_vel' in locals() else 0,\n            'energy_loss': energy_loss,\n            'position_history_length': len(self.position_history)\n        }\n\n    def validation_loop(self):\n        \"\"\"Main validation loop\"\"\"\n        # Execute test commands in sequence\n        current_time = self.get_clock().now()\n        elapsed = (current_time - self.test_start_time).nanoseconds / 1e9\n\n        if self.current_command < len(self.test_commands):\n            command = self.test_commands[self.current_command]\n\n            if elapsed < command['duration']:\n                # Execute current command\n                cmd = Twist()\n                cmd.linear.x = command['linear']\n                cmd.angular.z = command['angular']\n                self.cmd_vel_pub.publish(cmd)\n            else:\n                # Move to next command\n                self.current_command += 1\n                self.test_start_time = current_time\n\n        # Calculate physics metrics\n        metrics = self.calculate_physics_metrics()\n\n        if metrics:\n            # Validate physics behavior\n            validation_passed = True\n            validation_details = []\n\n            # Check if velocity is reasonable (not too high or too low)\n            if metrics['avg_velocity'] > 2.0:  # Too fast for our robot\n                validation_passed = False\n                validation_details.append(f\"Velocity too high: {metrics['avg_velocity']:.2f}\")\n            elif metrics['avg_velocity'] < 0.01 and self.current_command < len(self.test_commands) - 1:\n                validation_passed = False\n                validation_details.append(f\"Velocity too low: {metrics['avg_velocity']:.2f}\")\n\n            # Check energy conservation (should be mostly conserved in frictionless environment)\n            if metrics['energy_loss'] > 0.3:  # More than 30% energy loss is suspicious\n                validation_details.append(f\"High energy loss: {metrics['energy_loss']:.2f}\")\n\n            # Publish validation results\n            validation_msg = String()\n            validation_msg.data = f\"Valid: {validation_passed}, Avg Vel: {metrics['avg_velocity']:.2f}, \" \\\n                                 f\"Energy Loss: {metrics['energy_loss']:.2f}, \" \\\n                                 f\"Details: {'; '.join(validation_details) if validation_details else 'OK'}\"\n            self.validation_pub.publish(validation_msg)\n\n            if not validation_passed:\n                self.get_logger().warn(f\"Physics validation issue: {'; '.join(validation_details)}\")\n\n    def get_validation_report(self):\n        \"\"\"Generate a comprehensive physics validation report\"\"\"\n        report = \"Physics Validation Report\\n\"\n        report += \"=\" * 30 + \"\\n\"\n\n        metrics = self.calculate_physics_metrics()\n        if metrics:\n            report += f\"Average Velocity: {metrics['avg_velocity']:.3f} m/s\\n\"\n            report += f\"Expected Velocity: {metrics['expected_velocity']:.3f} m/s\\n\"\n            report += f\"Energy Loss: {metrics['energy_loss']:.3f}\\n\"\n            report += f\"Position Samples: {metrics['position_history_length']}\\n\"\n\n        report += f\"Total Runtime: {(self.get_clock().now() - self.start_time).nanoseconds / 1e9:.1f} s\\n\"\n        report += f\"Current Test Stage: {self.current_command}/{len(self.test_commands)}\\n\"\n\n        return report\n\ndef main(args=None):\n    rclpy.init(args=args)\n    validator = PhysicsValidator()\n\n    try:\n        rclpy.spin(validator)\n    except KeyboardInterrupt:\n        validator.get_logger().info(\"Physics Validator stopped by user\")\n        print(\"\\n\" + validator.get_validation_report())\n    finally:\n        validator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"quick-recap",children:"Quick Recap"}),"\n",(0,s.jsx)(n.p,{children:"In this lesson, we've covered:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mass Properties"}),": Setting realistic mass and inertial tensors for robot components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Friction Modeling"}),": Configuring friction coefficients for different surfaces and materials"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collision Detection"}),": Setting up proper collision geometries and contact properties"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Physics Validation"}),": Comparing simulation behavior with expected real-world physics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Material Properties"}),": Defining realistic material behaviors for different surfaces"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Proper physics modeling is essential for creating believable digital twins. The physics properties we've explored - mass, friction, collision detection, and material interactions - determine how accurately our simulated robots will behave compared to their real-world counterparts."}),"\n",(0,s.jsx)(n.p,{children:"In the next lesson, we'll explore Unity-based visualization and how it can complement Gazebo's physics simulation for enhanced robot development and debugging."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}}}]);
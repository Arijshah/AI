"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[399],{1256(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"physical-ai/the-robotic-nervous-system-ros2/practical-ros2-workflows","title":"Practical ROS 2 Workflows","description":"Overview","source":"@site/docs/physical-ai/the-robotic-nervous-system-ros2/practical-ros2-workflows.md","sourceDirName":"physical-ai/the-robotic-nervous-system-ros2","slug":"/physical-ai/the-robotic-nervous-system-ros2/practical-ros2-workflows","permalink":"/AI/docs/physical-ai/the-robotic-nervous-system-ros2/practical-ros2-workflows","draft":false,"unlisted":false,"editUrl":"https://github.com/arijh/physical-ai-book/tree/main/packages/create-docusaurus/templates/shared/docs/physical-ai/the-robotic-nervous-system-ros2/practical-ros2-workflows.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"Practical ROS 2 Workflows","title":"Practical ROS 2 Workflows"},"sidebar":"docs","previous":{"title":"URDF and Humanoid Robot Modeling","permalink":"/AI/docs/physical-ai/the-robotic-nervous-system-ros2/urdf-and-humanoid-robot-modeling"},"next":{"title":"Introduction to Gazebo Simulation","permalink":"/AI/docs/physical-ai/the-digital-twin-gazebo-unity/introduction-to-gazebo-simulation"}}');var a=s(4848),o=s(8453);const r={sidebar_label:"Practical ROS 2 Workflows",title:"Practical ROS 2 Workflows"},i="Practical ROS 2 Workflows",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Hands-on Steps",id:"hands-on-steps",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Small Simulation",id:"small-simulation",level:2},{value:"Quick Recap",id:"quick-recap",level:2},{value:"Summary of Chapter 2",id:"summary-of-chapter-2",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"practical-ros-2-workflows",children:"Practical ROS 2 Workflows"})}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"This lesson focuses on practical workflows and best practices for developing, testing, and deploying ROS 2 applications. We'll cover the complete development lifecycle from workspace setup to deployment, including debugging techniques, testing strategies, and tools that make ROS 2 development more efficient and robust."}),"\n",(0,a.jsx)(n.p,{children:"Understanding these practical workflows is essential for building production-ready robotic applications that are maintainable, scalable, and reliable."}),"\n",(0,a.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,a.jsx)(n.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Set up and organize ROS 2 workspaces effectively"}),"\n",(0,a.jsx)(n.li,{children:"Use ROS 2 tools for debugging and monitoring systems"}),"\n",(0,a.jsx)(n.li,{children:"Implement testing strategies for ROS 2 nodes"}),"\n",(0,a.jsx)(n.li,{children:"Apply best practices for package organization and documentation"}),"\n",(0,a.jsx)(n.li,{children:"Deploy ROS 2 applications in different environments"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"hands-on-steps",children:"Hands-on Steps"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Workspace Setup"}),": Create and organize a ROS 2 workspace"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Package Creation"}),": Build a complete ROS 2 package with multiple nodes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Testing Implementation"}),": Add unit and integration tests"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Debugging Techniques"}),": Use ROS 2 tools for debugging"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Deployment Preparation"}),": Package for distribution"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Understanding of ROS 2 concepts (nodes, topics, services, parameters)"}),"\n",(0,a.jsx)(n.li,{children:"Experience with Python and basic ROS 2 node development"}),"\n",(0,a.jsx)(n.li,{children:"Familiarity with Linux command line"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,a.jsx)(n.p,{children:"Let's start by creating a complete ROS 2 package structure with multiple nodes and proper organization:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# robot_control_package/robot_control_nodes/robot_control_nodes/motion_controller.py\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, Point\nfrom sensor_msgs.msg import LaserScan\nfrom nav_msgs.msg import Odometry\nfrom std_msgs.msg import String\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy\nimport math\n\nclass MotionController(Node):\n    """\n    A comprehensive motion controller node that integrates\n    navigation, obstacle avoidance, and state management\n    """\n    def __init__(self):\n        super().__init__(\'motion_controller\')\n\n        # Declare parameters\n        self.declare_parameter(\'linear_speed\', 0.3)\n        self.declare_parameter(\'angular_speed\', 0.5)\n        self.declare_parameter(\'obstacle_threshold\', 1.0)\n        self.declare_parameter(\'safety_margin\', 0.5)\n\n        # Get parameter values\n        self.linear_speed = self.get_parameter(\'linear_speed\').value\n        self.angular_speed = self.get_parameter(\'angular_speed\').value\n        self.obstacle_threshold = self.get_parameter(\'obstacle_threshold\').value\n        self.safety_margin = self.get_parameter(\'safety_margin\').value\n\n        # Create QoS profiles\n        sensor_qos = QoSProfile(\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            depth=10\n        )\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n        self.status_pub = self.create_publisher(String, \'/motion_status\', 10)\n\n        # Subscribers\n        self.laser_sub = self.create_subscription(\n            LaserScan, \'/scan\', self.laser_callback, sensor_qos)\n\n        self.odom_sub = self.create_subscription(\n            Odometry, \'/odom\', self.odom_callback, 10)\n\n        # Timers\n        self.control_timer = self.create_timer(0.1, self.control_loop)\n\n        # Robot state\n        self.current_pose = Point()\n        self.current_twist = Twist()\n        self.obstacle_detected = False\n        self.obstacle_distance = float(\'inf\')\n        self.robot_state = "IDLE"\n        self.goal_reached = False\n        self.navigation_active = False\n\n        # Goal position (will be set by external commands)\n        self.goal_position = Point()\n        self.goal_position.x = 0.0\n        self.goal_position.y = 0.0\n\n        # Logging\n        self.get_logger().info(f"Motion Controller initialized with speed: {self.linear_speed}m/s")\n\n    def laser_callback(self, msg):\n        """Process laser scan data for obstacle detection"""\n        # Get minimum distance in front (\xb130 degrees)\n        front_ranges = msg.ranges[330:] + msg.ranges[:30]\n        front_ranges = [r for r in front_ranges if not math.isnan(r) and 0.1 < r < 10.0]\n\n        if front_ranges:\n            self.obstacle_distance = min(front_ranges)\n            self.obstacle_detected = self.obstacle_distance < (self.obstacle_threshold + self.safety_margin)\n        else:\n            self.obstacle_distance = float(\'inf\')\n            self.obstacle_detected = False\n\n    def odom_callback(self, msg):\n        """Process odometry data to get current pose"""\n        self.current_pose.x = msg.pose.pose.position.x\n        self.current_pose.y = msg.pose.pose.position.y\n        self.current_pose.z = msg.pose.pose.position.z\n\n        # Extract orientation (simplified - just using z component for 2D)\n        self.current_twist.linear.x = msg.twist.twist.linear.x\n        self.current_twist.linear.y = msg.twist.twist.linear.y\n        self.current_twist.angular.z = msg.twist.twist.angular.z\n\n    def set_goal(self, x, y):\n        """Set navigation goal"""\n        self.goal_position.x = x\n        self.goal_position.y = y\n        self.navigation_active = True\n        self.goal_reached = False\n        self.get_logger().info(f"Navigation goal set to: ({x}, {y})")\n\n    def calculate_control_command(self):\n        """Calculate control command based on current state"""\n        cmd = Twist()\n\n        if not self.navigation_active:\n            return cmd\n\n        # Calculate distance to goal\n        dx = self.goal_position.x - self.current_pose.x\n        dy = self.goal_position.y - self.current_pose.y\n        distance_to_goal = math.sqrt(dx*dx + dy*dy)\n\n        # Check if goal is reached\n        if distance_to_goal < 0.2:  # 20cm tolerance\n            self.goal_reached = True\n            self.navigation_active = False\n            self.robot_state = "GOAL_REACHED"\n            return cmd\n\n        # Calculate desired angle to goal\n        desired_angle = math.atan2(dy, dx)\n\n        # Simple proportional controller for angular velocity\n        angle_diff = desired_angle\n        cmd.angular.z = max(-self.angular_speed, min(self.angular_speed, 2.0 * angle_diff))\n\n        # Move forward if not rotating significantly and no obstacle\n        if abs(cmd.angular.z) < 0.2 and not self.obstacle_detected:\n            cmd.linear.x = self.linear_speed\n            self.robot_state = "MOVING_TO_GOAL"\n        elif self.obstacle_detected:\n            cmd.linear.x = 0.0\n            cmd.angular.z = self.angular_speed  # Rotate to avoid\n            self.robot_state = "OBSTACLE_AVOIDANCE"\n        else:\n            cmd.linear.x = 0.0\n            self.robot_state = "ROTATING_TO_GOAL"\n\n        return cmd\n\n    def control_loop(self):\n        """Main control loop"""\n        cmd = self.calculate_control_command()\n\n        # Publish command\n        self.cmd_vel_pub.publish(cmd)\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = f"State: {self.robot_state}, Goal: ({self.goal_position.x:.2f}, {self.goal_position.y:.2f}), " \\\n                         f"Pos: ({self.current_pose.x:.2f}, {self.current_pose.y:.2f}), " \\\n                         f"Obstacle: {self.obstacle_detected}, Distance: {self.obstacle_distance:.2f}m"\n        self.status_pub.publish(status_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    controller = MotionController()\n\n    # Example: Set a goal after startup\n    import time\n    time.sleep(1)  # Wait for connections\n    controller.set_goal(2.0, 1.0)  # Move to (2, 1)\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        controller.get_logger().info("Motion Controller stopped by user")\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.p,{children:"Now let's create a diagnostic node that monitors the health of our ROS 2 system:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# robot_control_package/robot_control_nodes/robot_control_nodes/system_monitor.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus\nfrom rclpy.qos import QoSProfile\nimport psutil\nimport socket\n\nclass SystemMonitor(Node):\n    """\n    System monitoring node that publishes diagnostic information\n    """\n    def __init__(self):\n        super().__init__(\'system_monitor\')\n\n        # Publishers\n        self.diag_pub = self.create_publisher(DiagnosticArray, \'/diagnostics\', 10)\n        self.status_pub = self.create_publisher(String, \'/system_status\', 10)\n\n        # Timer for diagnostics\n        self.diag_timer = self.create_timer(1.0, self.publish_diagnostics)\n\n        self.get_logger().info("System Monitor initialized")\n\n    def get_cpu_usage(self):\n        """Get CPU usage percentage"""\n        return psutil.cpu_percent(interval=1)\n\n    def get_memory_usage(self):\n        """Get memory usage percentage"""\n        memory = psutil.virtual_memory()\n        return memory.percent\n\n    def get_disk_usage(self):\n        """Get disk usage percentage"""\n        disk = psutil.disk_usage(\'/\')\n        return (disk.used / disk.total) * 100\n\n    def get_network_status(self):\n        """Get basic network status"""\n        try:\n            # Try to connect to an external server to check internet\n            socket.create_connection(("8.8.8.8", 53), timeout=3)\n            return True\n        except OSError:\n            return False\n\n    def publish_diagnostics(self):\n        """Publish system diagnostic information"""\n        diag_array = DiagnosticArray()\n        diag_array.header.stamp = self.get_clock().now().to_msg()\n\n        # CPU Diagnostic\n        cpu_diag = DiagnosticStatus()\n        cpu_diag.name = "CPU Usage"\n        cpu_usage = self.get_cpu_usage()\n        cpu_diag.level = DiagnosticStatus.OK if cpu_usage < 80 else DiagnosticStatus.WARN if cpu_usage < 90 else DiagnosticStatus.ERROR\n        cpu_diag.message = f"CPU usage: {cpu_usage}%"\n        cpu_diag.hardware_id = "cpu"\n        cpu_diag.values = [\n            {"key": "usage_percent", "value": str(cpu_usage)},\n            {"key": "status", "value": "OK" if cpu_usage < 80 else "HIGH"}\n        ]\n        diag_array.status.append(cpu_diag)\n\n        # Memory Diagnostic\n        mem_diag = DiagnosticStatus()\n        mem_diag.name = "Memory Usage"\n        mem_usage = self.get_memory_usage()\n        mem_diag.level = DiagnosticStatus.OK if mem_usage < 80 else DiagnosticStatus.WARN if mem_usage < 90 else DiagnosticStatus.ERROR\n        mem_diag.message = f"Memory usage: {mem_usage}%"\n        mem_diag.hardware_id = "memory"\n        mem_diag.values = [\n            {"key": "usage_percent", "value": str(mem_usage)},\n            {"key": "status", "value": "OK" if mem_usage < 80 else "HIGH"}\n        ]\n        diag_array.status.append(mem_diag)\n\n        # Disk Diagnostic\n        disk_diag = DiagnosticStatus()\n        disk_diag.name = "Disk Usage"\n        disk_usage = self.get_disk_usage()\n        disk_diag.level = DiagnosticStatus.OK if disk_usage < 80 else DiagnosticStatus.WARN if disk_usage < 90 else DiagnosticStatus.ERROR\n        disk_diag.message = f"Disk usage: {disk_usage:.1f}%"\n        disk_diag.hardware_id = "disk"\n        disk_diag.values = [\n            {"key": "usage_percent", "value": f"{disk_usage:.1f}"},\n            {"key": "status", "value": "OK" if disk_usage < 80 else "HIGH"}\n        ]\n        diag_array.status.append(disk_diag)\n\n        # Network Diagnostic\n        net_diag = DiagnosticStatus()\n        net_diag.name = "Network Connectivity"\n        net_connected = self.get_network_status()\n        net_diag.level = DiagnosticStatus.OK if net_connected else DiagnosticStatus.ERROR\n        net_diag.message = "Network: Connected" if net_connected else "Network: Disconnected"\n        net_diag.hardware_id = "network"\n        net_diag.values = [\n            {"key": "connected", "value": str(net_connected)},\n            {"key": "status", "value": "OK" if net_connected else "ERROR"}\n        ]\n        diag_array.status.append(net_diag)\n\n        # Publish diagnostics\n        self.diag_pub.publish(diag_array)\n\n        # Publish simple status\n        status_msg = String()\n        status_msg.data = f"CPU: {cpu_usage:.1f}%, Mem: {mem_usage:.1f}%, Disk: {disk_usage:.1f}%, Net: {\'UP\' if net_connected else \'DOWN\'}"\n        self.status_pub.publish(status_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    monitor = SystemMonitor()\n\n    try:\n        rclpy.spin(monitor)\n    except KeyboardInterrupt:\n        monitor.get_logger().info("System Monitor stopped by user")\n    finally:\n        monitor.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.p,{children:"Let's also create a launch file to bring up our complete system:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# robot_control_package/robot_control_nodes/launch/navigation_system.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, RegisterEventHandler\nfrom launch.event_handlers import OnProcessExit\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    # Launch configuration variables\n    use_sim_time = LaunchConfiguration('use_sim_time', default='false')\n    log_level = LaunchConfiguration('log_level', default='info')\n\n    # Declare launch arguments\n    declare_use_sim_time = DeclareLaunchArgument(\n        'use_sim_time',\n        default_value='false',\n        description='Use simulation (Gazebo) clock if true'\n    )\n\n    declare_log_level = DeclareLaunchArgument(\n        'log_level',\n        default_value='info',\n        description='Log level for nodes'\n    )\n\n    # Motion controller node\n    motion_controller = Node(\n        package='robot_control_nodes',\n        executable='motion_controller',\n        name='motion_controller',\n        parameters=[\n            {'linear_speed': 0.3},\n            {'angular_speed': 0.5},\n            {'obstacle_threshold': 1.0},\n            {'safety_margin': 0.5}\n        ],\n        remappings=[\n            ('/cmd_vel', '/cmd_vel'),\n            ('/scan', '/scan'),\n            ('/odom', '/odom'),\n        ],\n        arguments=['--ros-args', '--log-level', log_level],\n        additional_env={'RCUTILS_LOGGING_USE_STDOUT': '1'},\n    )\n\n    # System monitor node\n    system_monitor = Node(\n        package='robot_control_nodes',\n        executable='system_monitor',\n        name='system_monitor',\n        parameters=[\n            {'use_sim_time': use_sim_time}\n        ],\n        arguments=['--ros-args', '--log-level', log_level],\n    )\n\n    # Joint state publisher (for visualization)\n    joint_state_publisher = Node(\n        package='joint_state_publisher',\n        executable='joint_state_publisher',\n        name='joint_state_publisher',\n        parameters=[\n            {'use_sim_time': use_sim_time}\n        ],\n    )\n\n    # Robot state publisher (for TF transforms)\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        parameters=[\n            {'use_sim_time': use_sim_time}\n        ],\n        arguments=[os.path.join(get_package_share_directory('robot_description'), 'urdf', 'robot.urdf')]\n        if os.path.exists(os.path.join(get_package_share_directory('robot_description'), 'urdf', 'robot.urdf'))\n        else []\n    )\n\n    # RViz2 for visualization\n    rviz_config = os.path.join(\n        get_package_share_directory('robot_control_nodes'),\n        'rviz',\n        'navigation_system.rviz'\n    )\n\n    rviz = Node(\n        package='rviz2',\n        executable='rviz2',\n        name='rviz2',\n        arguments=['-d', rviz_config],\n        parameters=[\n            {'use_sim_time': use_sim_time}\n        ],\n        condition='true'  # Only run if condition is met\n    )\n\n    # Return launch description\n    return LaunchDescription([\n        declare_use_sim_time,\n        declare_log_level,\n        motion_controller,\n        system_monitor,\n        joint_state_publisher,\n        robot_state_publisher,\n        # rviz  # Commented out as RViz config may not exist yet\n    ])\n"})}),"\n",(0,a.jsx)(n.h2,{id:"small-simulation",children:"Small Simulation"}),"\n",(0,a.jsx)(n.p,{children:"Let's create a testing framework for our ROS 2 nodes to demonstrate proper testing practices:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# robot_control_package/robot_control_nodes/test/test_motion_controller.py\nimport unittest\nimport rclpy\nfrom rclpy.executors import SingleThreadedExecutor\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, Point\nfrom sensor_msgs.msg import LaserScan\nfrom std_msgs.msg import String\nimport threading\nimport time\n\nclass TestMotionController(unittest.TestCase):\n    """\n    Unit tests for the MotionController node\n    """\n    @classmethod\n    def setUpClass(cls):\n        rclpy.init()\n\n    @classmethod\n    def tearDownClass(cls):\n        rclpy.shutdown()\n\n    def setUp(self):\n        # Create a test node to interact with the motion controller\n        self.test_node = Node(\'test_motion_controller\')\n        self.executor = SingleThreadedExecutor()\n        self.executor.add_node(self.test_node)\n\n        # Publishers for test inputs\n        self.laser_pub = self.test_node.create_publisher(LaserScan, \'/scan\', 10)\n        self.odom_pub = self.test_node.create_publisher(Odometry, \'/odom\', 10)\n\n        # Subscribers for test outputs\n        self.cmd_vel_sub = self.test_node.create_subscription(\n            Twist, \'/cmd_vel\', self.cmd_vel_callback, 10)\n        self.status_sub = self.test_node.create_subscription(\n            String, \'/motion_status\', self.status_callback, 10)\n\n        # Test variables\n        self.last_cmd_vel = None\n        self.last_status = None\n\n    def cmd_vel_callback(self, msg):\n        self.last_cmd_vel = msg\n\n    def status_callback(self, msg):\n        self.last_status = msg\n\n    def create_laser_scan_msg(self, ranges):\n        """Create a LaserScan message with specified ranges"""\n        from sensor_msgs.msg import LaserScan\n        msg = LaserScan()\n        msg.header.stamp = self.test_node.get_clock().now().to_msg()\n        msg.header.frame_id = \'laser_frame\'\n        msg.angle_min = -math.pi/2\n        msg.angle_max = math.pi/2\n        msg.angle_increment = math.pi / len(ranges)\n        msg.time_increment = 0.0\n        msg.scan_time = 0.0\n        msg.range_min = 0.1\n        msg.range_max = 10.0\n        msg.ranges = ranges\n        return msg\n\n    def test_obstacle_detection(self):\n        """Test that the controller stops when obstacles are detected"""\n        # Publish a laser scan with an obstacle close in front\n        obstacle_ranges = [0.5] * 360  # All ranges are 0.5m (close obstacle)\n        obstacle_scan = self.create_laser_scan_msg(obstacle_ranges)\n\n        self.laser_pub.publish(obstacle_scan)\n        time.sleep(0.2)  # Wait for processing\n\n        # Check that linear velocity is zero (stopped due to obstacle)\n        if self.last_cmd_vel:\n            self.assertEqual(self.last_cmd_vel.linear.x, 0.0)\n\n    def test_clear_path_movement(self):\n        """Test that the controller moves forward when path is clear"""\n        # Publish a laser scan with no obstacles\n        clear_ranges = [5.0] * 360  # All ranges are 5m (clear path)\n        clear_scan = self.create_laser_scan_msg(clear_ranges)\n\n        self.laser_pub.publish(clear_scan)\n        time.sleep(0.2)  # Wait for processing\n\n        # Check that robot is moving forward (linear velocity > 0)\n        if self.last_cmd_vel:\n            self.assertGreater(self.last_cmd_vel.linear.x, 0.0)\n\n    def test_rotation_behavior(self):\n        """Test rotation when obstacles are detected"""\n        # Publish a laser scan with obstacle on the left\n        ranges = [5.0] * 360\n        ranges[0:90] = [0.3] * 90  # Obstacle on the left\n        left_obstacle_scan = self.create_laser_scan_msg(ranges)\n\n        self.laser_pub.publish(left_obstacle_scan)\n        time.sleep(0.2)  # Wait for processing\n\n        # Check that robot rotates (angular velocity != 0)\n        if self.last_cmd_vel:\n            self.assertNotEqual(self.last_cmd_vel.angular.z, 0.0)\n\ndef main():\n    unittest.main()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.p,{children:"Let's also create a command-line tool for managing our ROS 2 system:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# robot_control_package/robot_control_nodes/robot_control_nodes/system_manager.py\n#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nfrom rclpy.qos import QoSProfile\nimport sys\nimport argparse\n\nclass SystemManager(Node):\n    \"\"\"\n    Command-line interface for managing the robot system\n    \"\"\"\n    def __init__(self):\n        super().__init__('system_manager')\n\n        # Publisher for system commands\n        self.command_pub = self.create_publisher(String, '/system_command', 10)\n\n        self.get_logger().info(\"System Manager ready\")\n\n    def send_command(self, command):\n        \"\"\"Send a command to the system\"\"\"\n        msg = String()\n        msg.data = command\n        self.command_pub.publish(msg)\n        self.get_logger().info(f\"Sent command: {command}\")\n\ndef main():\n    parser = argparse.ArgumentParser(description='ROS 2 System Manager')\n    parser.add_argument('command', choices=['start', 'stop', 'reset', 'calibrate', 'emergency_stop'],\n                       help='System command to execute')\n    parser.add_argument('--node', help='Specific node to target')\n\n    args = parser.parse_args()\n\n    rclpy.init()\n    manager = SystemManager()\n\n    # Wait for publisher to connect\n    time.sleep(0.5)\n\n    # Send the command\n    if args.node:\n        command = f\"{args.command}:{args.node}\"\n    else:\n        command = args.command\n\n    manager.send_command(command)\n    manager.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    import time\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"quick-recap",children:"Quick Recap"}),"\n",(0,a.jsx)(n.p,{children:"In this lesson, we've covered:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Complete Package Structure"}),": Creating well-organized ROS 2 packages with proper file hierarchy"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"System Monitoring"}),": Implementing diagnostic nodes to monitor system health"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Launch Files"}),": Creating comprehensive launch files for system deployment"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Testing Framework"}),": Developing unit tests for ROS 2 nodes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Command Line Tools"}),": Building management tools for system operation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Best Practices"}),": Proper error handling, logging, and parameter management"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"These practical workflows form the foundation of professional ROS 2 development. Proper organization, testing, and monitoring are essential for creating robust robotic applications that can be deployed in real-world scenarios."}),"\n",(0,a.jsx)(n.p,{children:"The combination of well-structured packages, comprehensive testing, and effective monitoring tools ensures that your ROS 2 applications are maintainable, reliable, and ready for production use."}),"\n",(0,a.jsx)(n.h2,{id:"summary-of-chapter-2",children:"Summary of Chapter 2"}),"\n",(0,a.jsx)(n.p,{children:'In Chapter 2: "The Robotic Nervous System (ROS 2)", we\'ve covered:'}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Introduction to ROS 2"}),": Core concepts including nodes, topics, services, and actions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Advanced Nodes and Parameters"}),": Creating sophisticated nodes with dynamic configuration"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"URDF and Humanoid Modeling"}),": Creating detailed robot models for simulation and control"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Practical Workflows"}),": Complete development, testing, and deployment practices"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'This chapter provides a solid foundation for understanding how ROS 2 serves as the "nervous system" of robotic applications, enabling complex systems to communicate and coordinate effectively.'})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>r,x:()=>i});var t=s(6540);const a={},o=t.createContext(a);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);
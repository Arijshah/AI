"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[182],{4245(e,n,a){a.r(n),a.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"physical-ai/the-robotic-nervous-system-ros2/ros2-nodes-and-parameters","title":"ROS 2 Nodes and Parameters","description":"Overview","source":"@site/docs/physical-ai/the-robotic-nervous-system-ros2/ros2-nodes-and-parameters.md","sourceDirName":"physical-ai/the-robotic-nervous-system-ros2","slug":"/physical-ai/the-robotic-nervous-system-ros2/ros2-nodes-and-parameters","permalink":"/physical-ai-book/docs/physical-ai/the-robotic-nervous-system-ros2/ros2-nodes-and-parameters","draft":false,"unlisted":false,"editUrl":"https://github.com/arijh/physical-ai-book/tree/main/packages/create-docusaurus/templates/shared/docs/physical-ai/the-robotic-nervous-system-ros2/ros2-nodes-and-parameters.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"ROS 2 Nodes and Parameters","title":"ROS 2 Nodes and Parameters"},"sidebar":"docs","previous":{"title":"Introduction to ROS 2","permalink":"/physical-ai-book/docs/physical-ai/the-robotic-nervous-system-ros2/introduction-to-ros2"},"next":{"title":"URDF and Humanoid Robot Modeling","permalink":"/physical-ai-book/docs/physical-ai/the-robotic-nervous-system-ros2/urdf-and-humanoid-robot-modeling"}}');var t=a(4848),r=a(8453);const o={sidebar_label:"ROS 2 Nodes and Parameters",title:"ROS 2 Nodes and Parameters"},l="ROS 2 Nodes and Parameters",i={},d=[{value:"Overview",id:"overview",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Hands-on Steps",id:"hands-on-steps",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Small Simulation",id:"small-simulation",level:2},{value:"Quick Recap",id:"quick-recap",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"ros-2-nodes-and-parameters",children:"ROS 2 Nodes and Parameters"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Nodes are the fundamental building blocks of ROS 2 applications, representing individual processes that perform specific functions within a robot system. In this lesson, we'll dive deeper into node creation, parameter management, and best practices for building robust ROS 2 nodes. We'll also explore how to create nodes that can be dynamically configured through parameters."}),"\n",(0,t.jsx)(n.p,{children:"Understanding nodes and parameters is crucial for building flexible and maintainable robot systems that can adapt to different environments and requirements."}),"\n",(0,t.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create complex ROS 2 nodes with multiple publishers, subscribers, and services"}),"\n",(0,t.jsx)(n.li,{children:"Implement parameter handling in ROS 2 nodes"}),"\n",(0,t.jsx)(n.li,{children:"Use ROS 2 launch files to manage multiple nodes"}),"\n",(0,t.jsx)(n.li,{children:"Apply best practices for node design and error handling"}),"\n",(0,t.jsx)(n.li,{children:"Configure nodes dynamically through parameters"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"hands-on-steps",children:"Hands-on Steps"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Advanced Node Creation"}),": Build a node with multiple communication patterns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameter Implementation"}),": Add dynamic configuration to nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Launch File Creation"}),": Create launch files to manage node deployment"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node Testing"}),": Test nodes with different parameter configurations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Implement robust error handling in nodes"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understanding of basic ROS 2 concepts (nodes, topics, services)"}),"\n",(0,t.jsx)(n.li,{children:"Basic Python programming knowledge"}),"\n",(0,t.jsx)(n.li,{children:"Experience with object-oriented programming"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,t.jsx)(n.p,{children:"Let's start by creating a more sophisticated node that demonstrates multiple communication patterns and parameter handling:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# advanced_robot_node.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\nfrom std_msgs.msg import String, Float32\nfrom example_interfaces.srv import SetBool\nimport math\n\nclass AdvancedRobotNode(Node):\n    """\n    Advanced robot node demonstrating multiple ROS 2 concepts:\n    - Multiple publishers and subscribers\n    - Parameter handling\n    - Services\n    - Dynamic reconfiguration\n    """\n    def __init__(self):\n        super().__init__(\'advanced_robot_node\')\n\n        # Declare parameters with default values\n        self.declare_parameter(\'robot_name\', \'turtlebot\')\n        self.declare_parameter(\'linear_speed\', 0.2)\n        self.declare_parameter(\'angular_speed\', 0.5)\n        self.declare_parameter(\'obstacle_threshold\', 1.0)\n        self.declare_parameter(\'safety_mode\', True)\n\n        # Get parameter values\n        self.robot_name = self.get_parameter(\'robot_name\').value\n        self.linear_speed = self.get_parameter(\'linear_speed\').value\n        self.angular_speed = self.get_parameter(\'angular_speed\').value\n        self.obstacle_threshold = self.get_parameter(\'obstacle_threshold\').value\n        self.safety_mode = self.get_parameter(\'safety_mode\').value\n\n        # Create QoS profile for sensor data (with reliability)\n        sensor_qos = QoSProfile(\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            history=HistoryPolicy.KEEP_LAST,\n            depth=10\n        )\n\n        # Publishers\n        self.cmd_vel_publisher = self.create_publisher(Twist, \'/cmd_vel\', 10)\n        self.status_publisher = self.create_publisher(String, \'/robot_status\', 10)\n        self.distance_publisher = self.create_publisher(Float32, \'/obstacle_distance\', 10)\n\n        # Subscribers\n        self.laser_subscriber = self.create_subscription(\n            LaserScan,\n            \'/scan\',\n            self.laser_callback,\n            sensor_qos\n        )\n\n        # Services\n        self.safety_service = self.create_service(\n            SetBool,\n            \'/toggle_safety_mode\',\n            self.toggle_safety_mode_callback\n        )\n\n        # Timer for main control loop\n        self.control_timer = self.create_timer(0.1, self.control_loop)\n\n        # Robot state\n        self.obstacle_detected = False\n        self.obstacle_distance = float(\'inf\')\n        self.robot_state = "IDLE"\n        self.emergency_stop = False\n\n        # Parameter callback\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n        self.get_logger().info(f"Advanced Robot Node initialized for {self.robot_name}")\n        self.get_logger().info(f"Parameters - Speed: {self.linear_speed}m/s, Threshold: {self.obstacle_threshold}m")\n\n    def parameter_callback(self, params):\n        """\n        Callback for parameter changes\n        """\n        for param in params:\n            if param.name == \'linear_speed\' and param.type_ == Parameter.Type.DOUBLE:\n                self.linear_speed = param.value\n                self.get_logger().info(f"Linear speed updated to: {self.linear_speed}")\n            elif param.name == \'angular_speed\' and param.type_ == Parameter.Type.DOUBLE:\n                self.angular_speed = param.value\n                self.get_logger().info(f"Angular speed updated to: {self.angular_speed}")\n            elif param.name == \'obstacle_threshold\' and param.type_ == Parameter.Type.DOUBLE:\n                self.obstacle_threshold = param.value\n                self.get_logger().info(f"Obstacle threshold updated to: {self.obstacle_threshold}")\n            elif param.name == \'safety_mode\' and param.type_ == Parameter.Type.BOOL:\n                self.safety_mode = param.value\n                self.get_logger().info(f"Safety mode updated to: {self.safety_mode}")\n\n        return SetBool.Response(success=True, message="Parameters updated")\n\n    def laser_callback(self, msg):\n        """\n        Process laser scan data to detect obstacles\n        """\n        # Get the minimum distance from the front sector (\xb130 degrees)\n        front_ranges = msg.ranges[330:] + msg.ranges[:30]  # Front 60 degrees\n        front_ranges = [r for r in front_ranges if not math.isnan(r) and r > 0 and r < 10.0]\n\n        if front_ranges:\n            self.obstacle_distance = min(front_ranges)\n            self.obstacle_detected = self.obstacle_distance < self.obstacle_threshold\n        else:\n            self.obstacle_distance = float(\'inf\')\n            self.obstacle_detected = False\n\n    def toggle_safety_mode_callback(self, request, response):\n        """\n        Service callback to toggle safety mode\n        """\n        self.safety_mode = request.data\n        response.success = True\n        response.message = f"Safety mode set to {self.safety_mode}"\n        self.get_logger().info(f"Safety mode toggled: {self.safety_mode}")\n        return response\n\n    def control_loop(self):\n        """\n        Main control loop with parameter-based behavior\n        """\n        cmd_msg = Twist()\n\n        if self.emergency_stop:\n            # Emergency stop - zero all velocities\n            cmd_msg.linear.x = 0.0\n            cmd_msg.angular.z = 0.0\n            self.robot_state = "EMERGENCY_STOP"\n        elif self.obstacle_detected and self.safety_mode:\n            # Obstacle detected in safety mode\n            self.robot_state = "AVOIDING"\n            cmd_msg.linear.x = 0.0  # Stop linear motion\n            cmd_msg.angular.z = self.angular_speed  # Rotate to avoid\n        else:\n            # Normal operation\n            self.robot_state = "MOVING"\n            cmd_msg.linear.x = self.linear_speed\n            cmd_msg.angular.z = 0.0\n\n        # Publish command\n        self.cmd_vel_publisher.publish(cmd_msg)\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = f"Robot: {self.robot_name}, State: {self.robot_state}, " \\\n                         f"Obstacle: {self.obstacle_detected}, Distance: {self.obstacle_distance:.2f}m"\n        self.status_publisher.publish(status_msg)\n\n        # Publish obstacle distance\n        distance_msg = Float32()\n        distance_msg.data = self.obstacle_distance\n        self.distance_publisher.publish(distance_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    advanced_robot_node = AdvancedRobotNode()\n\n    try:\n        rclpy.spin(advanced_robot_node)\n    except KeyboardInterrupt:\n        advanced_robot_node.get_logger().info("Advanced Robot Node stopped by user")\n    finally:\n        advanced_robot_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now let's create a launch file to manage this node with different configurations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# robot_launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    # Declare launch arguments\n    robot_name_arg = DeclareLaunchArgument(\n        'robot_name',\n        default_value='turtlebot',\n        description='Name of the robot'\n    )\n\n    linear_speed_arg = DeclareLaunchArgument(\n        'linear_speed',\n        default_value='0.2',\n        description='Linear speed of the robot'\n    )\n\n    angular_speed_arg = DeclareLaunchArgument(\n        'angular_speed',\n        default_value='0.5',\n        description='Angular speed of the robot'\n    )\n\n    obstacle_threshold_arg = DeclareLaunchArgument(\n        'obstacle_threshold',\n        default_value='1.0',\n        description='Obstacle detection threshold'\n    )\n\n    # Get launch configurations\n    robot_name = LaunchConfiguration('robot_name')\n    linear_speed = LaunchConfiguration('linear_speed')\n    angular_speed = LaunchConfiguration('angular_speed')\n    obstacle_threshold = LaunchConfiguration('obstacle_threshold')\n\n    # Create the robot node\n    robot_node = Node(\n        package='robot_package',\n        executable='advanced_robot_node',\n        name='advanced_robot_node',\n        parameters=[\n            {\n                'robot_name': robot_name,\n                'linear_speed': linear_speed,\n                'angular_speed': angular_speed,\n                'obstacle_threshold': obstacle_threshold,\n                'safety_mode': True\n            }\n        ],\n        remappings=[\n            ('/cmd_vel', '/cmd_vel'),\n            ('/scan', '/scan'),\n        ]\n    )\n\n    return LaunchDescription([\n        robot_name_arg,\n        linear_speed_arg,\n        angular_speed_arg,\n        obstacle_threshold_arg,\n        robot_node\n    ])\n"})}),"\n",(0,t.jsx)(n.p,{children:"Let's also create a parameter file for configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'# robot_params.yaml\nadvanced_robot_node:\n  ros__parameters:\n    robot_name: "turtlebot"\n    linear_speed: 0.3\n    angular_speed: 0.6\n    obstacle_threshold: 1.5\n    safety_mode: true\n'})}),"\n",(0,t.jsx)(n.h2,{id:"small-simulation",children:"Small Simulation"}),"\n",(0,t.jsx)(n.p,{children:"Let's create a simulation environment that demonstrates parameter changes affecting robot behavior:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# parameter_simulation.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\nfrom std_msgs.msg import String\nfrom example_interfaces.srv import SetParameters\nimport time\n\nclass ParameterSimulationNode(Node):\n    """\n    Node to demonstrate parameter changes affecting robot behavior\n    """\n    def __init__(self):\n        super().__init__(\'parameter_simulation_node\')\n\n        # Declare parameters\n        self.declare_parameter(\'simulation_speed\', 1.0)\n        self.declare_parameter(\'environment_type\', \'indoor\')\n        self.declare_parameter(\'difficulty_level\', 1)\n\n        # Get initial parameter values\n        self.simulation_speed = self.get_parameter(\'simulation_speed\').value\n        self.environment_type = self.get_parameter(\'environment_type\').value\n        self.difficulty_level = self.get_parameter(\'difficulty_level\').value\n\n        # Publisher for simulation status\n        self.status_publisher = self.create_publisher(String, \'/simulation_status\', 10)\n\n        # Timer for simulation updates\n        self.sim_timer = self.create_timer(1.0 / self.simulation_speed, self.simulation_step)\n\n        # Parameter callback\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n        self.step_count = 0\n        self.get_logger().info(f"Parameter Simulation started - Speed: {self.simulation_speed}, Environment: {self.environment_type}")\n\n    def parameter_callback(self, params):\n        """\n        Handle parameter changes\n        """\n        for param in params:\n            if param.name == \'simulation_speed\':\n                self.simulation_speed = param.value\n                # Update timer rate\n                self.sim_timer.timer_period_ns = int(1e9 / self.simulation_speed)\n                self.get_logger().info(f"Simulation speed updated to: {self.simulation_speed}")\n            elif param.name == \'environment_type\':\n                self.environment_type = param.value\n                self.get_logger().info(f"Environment type updated to: {self.environment_type}")\n            elif param.name == \'difficulty_level\':\n                self.difficulty_level = param.value\n                self.get_logger().info(f"Difficulty level updated to: {self.difficulty_level}")\n\n        return SetParameters.Response(results=[rclpy.Parameter.Type.DECLARE_SUCCESSFUL for p in params])\n\n    def simulation_step(self):\n        """\n        Simulation step that demonstrates parameter effects\n        """\n        self.step_count += 1\n\n        # Simulate different behaviors based on parameters\n        if self.environment_type == \'indoor\':\n            obstacle_factor = 1.0\n        elif self.environment_type == \'outdoor\':\n            obstacle_factor = 0.7\n        else:\n            obstacle_factor = 0.5\n\n        difficulty_modifier = self.difficulty_level * 0.1\n\n        # Simulate some "sensor" data\n        simulated_data = f"Step {self.step_count}: Env={self.environment_type}, Diff={self.difficulty_level}, Factor={obstacle_factor:.1f}"\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = simulated_data\n        self.status_publisher.publish(status_msg)\n\n        self.get_logger().info(f"Simulation: {simulated_data}")\n\ndef main(args=None):\n    rclpy.init(args=args)\n    param_sim_node = ParameterSimulationNode()\n\n    try:\n        rclpy.spin(param_sim_node)\n    except KeyboardInterrupt:\n        param_sim_node.get_logger().info("Parameter Simulation stopped by user")\n    finally:\n        param_sim_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.h2,{id:"quick-recap",children:"Quick Recap"}),"\n",(0,t.jsx)(n.p,{children:"In this lesson, we've covered:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Advanced Node Creation"}),": Building nodes with multiple publishers, subscribers, and services"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameter Management"}),": Declaring, using, and dynamically updating parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Launch Files"}),": Managing multiple nodes and configurations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameter Callbacks"}),": Responding to parameter changes at runtime"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Best Practices"}),": Proper error handling, QoS profiles, and node design patterns"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Parameters provide a powerful way to configure robot behavior without recompiling code. They allow the same node to operate in different environments or under different conditions by simply changing parameter values. This flexibility is essential for deploying robots in various scenarios and for tuning performance during development."}),"\n",(0,t.jsx)(n.p,{children:"The combination of nodes, parameters, and launch files creates a robust framework for building complex robot systems that can be easily configured and managed."}),"\n",(0,t.jsx)(n.p,{children:"In the next lesson, we'll explore URDF (Unified Robot Description Format) for modeling humanoid robots and how to integrate these models with ROS 2."})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453(e,n,a){a.d(n,{R:()=>o,x:()=>l});var s=a(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);
"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[928],{3349(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"physical-ai/introduction-to-physical-ai/what-is-physical-ai","title":"What is Physical AI?","description":"Overview","source":"@site/docs/physical-ai/introduction-to-physical-ai/what-is-physical-ai.md","sourceDirName":"physical-ai/introduction-to-physical-ai","slug":"/physical-ai/introduction-to-physical-ai/what-is-physical-ai","permalink":"/AI/docs/physical-ai/introduction-to-physical-ai/what-is-physical-ai","draft":false,"unlisted":false,"editUrl":"https://github.com/arijh/physical-ai-book/tree/main/packages/create-docusaurus/templates/shared/docs/physical-ai/introduction-to-physical-ai/what-is-physical-ai.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"What is Physical AI?","title":"What is Physical AI?"},"sidebar":"docs","previous":{"title":"Introduction to Physical AI","permalink":"/AI/docs/"},"next":{"title":"Humanoid Robotics Overview","permalink":"/AI/docs/physical-ai/introduction-to-physical-ai/humanoid-robotics-overview"}}');var o=i(4848),s=i(8453);const a={sidebar_label:"What is Physical AI?",title:"What is Physical AI?"},r="What is Physical AI?",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Hands-on Steps",id:"hands-on-steps",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Small Simulation",id:"small-simulation",level:2},{value:"Quick Recap",id:"quick-recap",level:2}];function h(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"what-is-physical-ai",children:"What is Physical AI?"})}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"Physical AI represents the convergence of artificial intelligence and physical systems, enabling machines to interact intelligently with the real world. Unlike traditional AI that operates primarily in digital spaces, Physical AI encompasses robotics, embodied intelligence, and systems that perceive, reason, and act in physical environments."}),"\n",(0,o.jsx)(e.p,{children:"In this lesson, you'll learn the fundamental concepts of Physical AI and how it differs from conventional AI approaches. We'll explore practical applications and get hands-on with simple simulations."}),"\n",(0,o.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Define Physical AI and distinguish it from traditional AI"}),"\n",(0,o.jsx)(e.li,{children:"Identify key components of Physical AI systems"}),"\n",(0,o.jsx)(e.li,{children:"Recognize applications of Physical AI in real-world scenarios"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"hands-on-steps",children:"Hands-on Steps"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Setup Environment"}),": Ensure you have a Python environment ready"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Install Dependencies"}),": Install required packages for simulation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Explore Basic Concepts"}),": Work with simple sensor and actuator models"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Run Simple Simulation"}),": Execute a basic Physical AI scenario"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Basic Python knowledge"}),"\n",(0,o.jsx)(e.li,{children:"Familiarity with concepts like sensors and actuators"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,o.jsx)(e.p,{children:"Let's start with a simple Physical AI concept - a robot that senses its environment and makes decisions:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import math\nimport random\n\nclass SimpleRobot:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n        self.orientation = 0  # angle in radians\n\n    def sense_environment(self):\n        """Simulate sensing the environment"""\n        # Simulate detecting obstacles in front, left, right\n        front_obstacle = random.random() < 0.3\n        left_obstacle = random.random() < 0.3\n        right_obstacle = random.random() < 0.3\n\n        return {\n            \'front\': front_obstacle,\n            \'left\': left_obstacle,\n            \'right\': right_obstacle\n        }\n\n    def move_forward(self, distance=1):\n        """Move the robot forward"""\n        self.x += distance * math.cos(self.orientation)\n        self.y += distance * math.sin(self.orientation)\n\n    def turn(self, angle_change):\n        """Turn the robot by changing orientation"""\n        self.orientation += angle_change\n\ndef simple_navigation(robot):\n    """Simple navigation algorithm"""\n    sensor_data = robot.sense_environment()\n\n    if sensor_data[\'front\']:\n        # Obstacle in front, turn randomly\n        if sensor_data[\'left\'] and not sensor_data[\'right\']:\n            robot.turn(-math.pi/4)  # Turn right\n        elif not sensor_data[\'left\'] and sensor_data[\'right\']:\n            robot.turn(math.pi/4)   # Turn left\n        else:\n            # Both sides clear, pick random direction\n            robot.turn(random.choice([-math.pi/4, math.pi/4]))\n    else:\n        # No obstacle in front, move forward\n        robot.move_forward()\n\n# Example usage\nrobot = SimpleRobot(0, 0)\nprint(f"Initial position: ({robot.x:.2f}, {robot.y:.2f})")\n\nfor step in range(10):\n    simple_navigation(robot)\n    print(f"Step {step+1}: Position: ({robot.x:.2f}, {robot.y:.2f}), Orientation: {robot.orientation:.2f}")\n'})}),"\n",(0,o.jsx)(e.h2,{id:"small-simulation",children:"Small Simulation"}),"\n",(0,o.jsx)(e.p,{children:"Now let's extend our example to visualize the robot's movement in a simple grid environment:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import matplotlib.pyplot as plt\nimport numpy as np\n\nclass GridEnvironment:\n    def __init__(self, width=20, height=20):\n        self.width = width\n        self.height = height\n        # Randomly place some obstacles\n        self.obstacles = set()\n        for _ in range(int(width * height * 0.1)):  # 10% obstacles\n            x = random.randint(0, width-1)\n            y = random.randint(0, height-1)\n            self.obstacles.add((x, y))\n\n    def is_valid_position(self, x, y):\n        """Check if position is within bounds and not an obstacle"""\n        if x < 0 or x >= self.width or y < 0 or y >= self.height:\n            return False\n        return (int(x), int(y)) not in self.obstacles\n\n    def visualize(self, robot_positions):\n        """Visualize the environment and robot path"""\n        grid = np.zeros((self.height, self.width))\n\n        # Mark obstacles\n        for obs_x, obs_y in self.obstacles:\n            grid[obs_y, obs_x] = 0.5\n\n        # Mark robot path\n        for i, (x, y) in enumerate(robot_positions):\n            if 0 <= int(y) < self.height and 0 <= int(x) < self.width:\n                # Color the path darker as the robot progresses\n                grid[int(y), int(x)] = 0.8 + (0.2 * i / len(robot_positions))\n\n        plt.figure(figsize=(10, 8))\n        plt.imshow(grid, cmap=\'viridis\', origin=\'lower\')\n        plt.colorbar(label=\'Path Progression\')\n        plt.title(\'Physical AI Robot Navigation Simulation\')\n        plt.xlabel(\'X Coordinate\')\n        plt.ylabel(\'Y Coordinate\')\n        plt.show()\n\ndef simulate_robot_path(steps=50):\n    """Simulate robot path in grid environment"""\n    env = GridEnvironment()\n    robot = SimpleRobot(1, 1)\n    positions = [(robot.x, robot.y)]\n\n    for step in range(steps):\n        # Update robot based on environment\n        sensor_data = robot.sense_environment()\n\n        # Simple navigation: avoid obstacles\n        if sensor_data[\'front\']:\n            # Turn randomly to avoid obstacle\n            robot.turn(random.choice([-math.pi/3, math.pi/3]))\n        else:\n            # Move forward if no obstacle\n            robot.move_forward(0.5)\n\n        # Store position\n        positions.append((robot.x, robot.y))\n\n        # Keep robot within environment bounds\n        if not env.is_valid_position(robot.x, robot.y):\n            robot.x = max(0, min(env.width-1, robot.x))\n            robot.y = max(0, min(env.height-1, robot.y))\n\n    return env, positions\n\n# Run simulation\nenv, path = simulate_robot_path()\nprint(f"Simulation completed. Robot traveled {len(path)} steps.")\nprint(f"Final position: ({path[-1][0]:.2f}, {path[-1][1]:.2f})")\n'})}),"\n",(0,o.jsx)(e.h2,{id:"quick-recap",children:"Quick Recap"}),"\n",(0,o.jsx)(e.p,{children:"In this lesson, we've covered:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Definition"}),": Physical AI combines AI with physical systems to interact with the real world"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Key Components"}),": Sensors for perception, processors for reasoning, actuators for action"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Hands-on Experience"}),": Created a simple robot simulator with navigation capabilities"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Practical Application"}),": Demonstrated how Physical AI systems make decisions based on environmental input"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Physical AI represents a shift from purely digital AI to systems that must navigate the complexities of the physical world. This requires considering factors like uncertainty, noise, real-time constraints, and the physics of motion and interaction."}),"\n",(0,o.jsx)(e.p,{children:"In the next lesson, we'll explore how humanoid robots embody these Physical AI principles and examine the challenges and opportunities in humanoid robotics."})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(h,{...n})}):h(n)}},8453(n,e,i){i.d(e,{R:()=>a,x:()=>r});var t=i(6540);const o={},s=t.createContext(o);function a(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);